section .data
    ;num1 dd 8                     ; Define a double word (32-bit) variable and initialize it with value 8
    ;num2 dd 7                     ; Define another double word variable and initialize it with value 5
    msg db 'Result', 10, 0     ; Define a message to print before the result, including newline (10 is ASCII code for newline)
    msg_len equ $-msg-1           ; Calculate the length of the message string
    inMsg db "Input number: ", 10, 0
    inLen equ $-inMsg-1
    newline db 10, 0           ; Define newline character (10 is ASCII code for newline)

section .bss
    num1    resb 4
    num2    resb 4
    ascii_buff resb 4            ; Reserve space for ASCII representation (up to 10 characters)

section .text
    global _start

_start:
    ; Input variables
    mov eax, 4
    mov edx, inLen
    mov ecx, inMsg
    mov ebx, 1
    int 0x80
    
    ; Read variables
    mov eax, 3
    mov edx, 2
    mov ecx, num1
    mov ebx, 0
    int 0x80
    
    ; Input variables
    mov eax, 4
    mov edx, inLen
    mov ecx, inMsg
    mov ebx, 1
    int 0x80
    
    ; Read variables
    mov eax, 3
    mov edx, 2
    mov ecx, num2
    mov ebx, 0
    int 0x80
    
    ; (It only allow enter single Number, transfer to num first)
    mov eax, dword [num1]    ; Move the value of num1 into register EAX
    sub eax, '0'        ; convert char to num
    mov ebx, dword [num2]    ; Move the value of num1 into register EAX
    sub ebx, '0'        ; convert char to num
    
    ; Addition
    add eax, ebx    ; Add the value of num2 to register EAX
    
    ; Convert the number to ASCII
    mov esi, ascii_buff        ; Point ESI to the buffer for ASCII representation
    mov ecx, 4               ; Set up loop counter for 10 digits max
    
convert_loop:
    mov edx, 0                 ; Clear EDX for division
    mov ebx, 10                ; Divisor (base 10)
    div ebx                    ; Divide EAX by EBX, quotient in EAX, remainder in EDX
    add dl, '0'                ; Convert remainder to ASCII character
    dec esi                    ; Move buffer pointer backward
    mov [esi], dl              ; Store ASCII character in the buffer
    test eax, eax              ; Check if quotient is zero
    jnz convert_loop           ; If not, continue the loop
    
    ; Print the output message
    mov eax, 4                 ; Syscall number for sys_write
    mov ebx, 1                 ; File descriptor (stdout)
    mov ecx, msg               ; Message to print
    mov edx, msg_len           ; Message length
    int 0x80                   ; Call kernel
    
    ; Print the ASCII representation
    mov eax, 4                 ; Syscall number for sys_write
    mov ebx, 1                 ; File descriptor (stdout)
    mov ecx, esi              ; Address of ASCII representation
    mov edx, 4                ; Message length
    int 0x80                   ; Call kernel
    
    ; Print newline after the result
    mov eax, 4                 ; Syscall number for sys_write
    mov ebx, 1                 ; File descriptor (stdout)
    mov ecx, newline           ; Address of newline character
    mov edx, 1                 ; Message length (1 character)
    int 0x80                   ; Call kernel

    ; Exit the program
    mov eax, 1                 ; Syscall number for sys_exit
    xor ebx, ebx               ; Return 0 status
    int 0x80                   ; Call kernel